grammar Pony
{
    options
    {
        start = module
        space = _
        more = more
        matches = first // unconditionally use first match of any rule
    }

    rules
    {
        module:
            STRING? use* class_def* EOF

        use:
            'use' (ID '=')? (STRING | use_ffi) ('if' infix)?

        use_ffi:
            '@' (ID | STRING) typeargs '(' params? ')' '?'?

        class-kind:
            'type' | 'interface' | 'trait' | 'primitive' | 'struct' | 'class' | 'actor'

        class_def: 
            class-kind anno? '@'? cap? ID typeparams? ('is' type)? STRING? members

        members:
            field* method*

        field-kind:
            'var' | 'let' | 'embed'

        field:
            field-kind ID ':' type ('=' infix)? STRING?

        method-kind:
            'fun' | 'be' | 'new'

        method:
            method-kind anno? (cap | '@')? ID typeparams? '(' params? ')' (':' type)? '?'? STRING? ('=>' rawseq)?

        anno:
            ('\\' ID (',' ID)* '\\')

        annotatedrawseq:
            anno? (exprseq | jump)

        rawseq
            : exprseq
            | jump

        exprseq:
            assignment (semiexpr | nosemi)?

        nextexprseq:
            nextassignment (semiexpr | nosemi)?

        nosemi
            : nextexprseq
            | jump

        semiexpr:
            ';' (exprseq | jump)

        jump:
            ('return' | 'break' | 'continue' | 'error' | 'compile_intrinsic' | 'compile_error') rawseq?

        nextassignment:
            nextinfix ('=' assignment)?

        assignment:
            infix ('=' assignment)?

        nextinfix:
            nextterm antlr_0*

        infix:
            term antlr_0*

        isop:
            ('is' | 'isnt') term

        infix-operator
            : 'and'
            | 'or'
            | 'xor'

            | '+~'
            | '+'
            | '-~'
            | '-'
            | '*~'
            | '*'
            | '/~'
            | '/'
            | '%%~'
            | '%%'
            | '%~'
            | '%'

            | '<<~'
            | '<<'
            | '<=~'
            | '<='
            | '<~'
            | '<'

            | '>>~'
            | '>>'
            | '>=~'
            | '>='
            | '>~'
            | '>'

            | '==~'
            | '=='
            | '!=~'
            | '!='

        binop:
            infix-operator '?'? term

        @single
        nextterm
            : 'if'      anno? rawseq 'then' rawseq (elseif | ('else' annotatedrawseq))? 'end'
            | 'ifdef'   anno? infix 'then' rawseq (elseifdef | ('else' annotatedrawseq))? 'end'
            | 'iftype'  anno? iftype (elseiftype | ('else' annotatedrawseq))? 'end'
            | 'match'   anno? rawseq caseexpr* ('else' annotatedrawseq)? 'end'
            | 'while'   anno? rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'repeat'  anno? rawseq 'until' annotatedrawseq ('else' annotatedrawseq)? 'end'
            | 'for'     anno? idseq 'in' rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'with'    anno? (withelem (',' withelem)*) 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'try'     anno? rawseq ('else' annotatedrawseq)? ('then' annotatedrawseq)? 'end'
            | 'recover' anno? cap? rawseq 'end'
            | 'consume' cap? term
            | nextpattern
            | '#' postfix

        @single
        term
            : 'if'      anno? rawseq 'then' rawseq (elseif | ('else' annotatedrawseq))? 'end'
            | 'ifdef'   anno? infix 'then' rawseq (elseifdef | ('else' annotatedrawseq))? 'end'
            | 'iftype'  anno? iftype (elseiftype | ('else' annotatedrawseq))? 'end'
            | 'match'   anno? rawseq caseexpr* ('else' annotatedrawseq)? 'end'
            | 'while'   anno? rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'repeat'  anno? rawseq 'until' annotatedrawseq ('else' annotatedrawseq)? 'end'
            | 'for'     anno? idseq 'in' rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'with'    anno? (withelem (',' withelem)*) 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'try'     anno? rawseq ('else' annotatedrawseq)? ('then' annotatedrawseq)? 'end'
            | 'recover' anno? cap? rawseq 'end'
            | 'consume' cap? term
            | pattern
            | '#' postfix

        withelem:
            idseq '=' rawseq

        caseexpr:
            '|' anno? casepattern? ('if' rawseq)? ('=>' rawseq)?

        elseiftype:
            'elseif' anno? iftype (elseiftype | ('else' annotatedrawseq))?

        iftype:
            type '<:' type 'then' rawseq

        elseifdef:
            'elseif' anno? infix 'then' rawseq (elseifdef | ('else' annotatedrawseq))?

        elseif:
            'elseif' anno? rawseq 'then' rawseq (elseif | ('else' annotatedrawseq))?

        idseq
            : ID
            | '(' idseq_in_seq (',' idseq_in_seq)* ')'

        idseq_in_seq
            : ID
            | '(' idseq_in_seq (',' idseq_in_seq)* ')'

        nextpattern
            : ('var' | 'let' | 'embed') ID (':' type)?
            | nextparampattern

        casepattern
            : ('var' | 'let' | 'embed') ID (':' type)?
            | caseparampattern

        pattern
            : ('var' | 'let' | 'embed') ID (':' type)?
            | parampattern

        nextparampattern
            : ('not' | 'addressof' | MINUS_NEW | MINUS_TILDE_NEW | 'digestof') parampattern
            | nextpostfix

        caseparampattern
            : ('not' | 'addressof' | '-' | '-~' | MINUS_NEW | MINUS_TILDE_NEW | 'digestof') caseparampattern
            | casepostfix

        parampattern
            : ('not' | 'addressof' | '-' | '-~' | MINUS_NEW | MINUS_TILDE_NEW | 'digestof') parampattern
            | postfix

        nextpostfix:
            nextatom antlr_2*

        casepostfix:
            caseatom antlr_2*

        postfix:
            atom antlr_2*

        call:
            '(' positional? named? ')' '?'?

        chain:
            '.>' ID

        tilde:
            '~' ID

        dot:
            '.' ID

        nextatom
            : ID
            | 'this'
            | literal
            | LPAREN_NEW rawseq tuple? ')'
            | LSQUARE_NEW ('as' type ':')? rawseq? ']'
            | 'object' anno? cap? ('is' type)? members 'end'
            | '{' anno? cap? ID? typeparams? '(' lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
            | '@{' anno? cap? ID? typeparams? '(' lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
            | '@' (ID | STRING) typeargs? '(' positional? named? ')' '?'?
            | '__loc'
            | 'if' anno? rawseq 'then' rawseq (elseif | ('else' annotatedrawseq))? 'end'
            | 'while' anno? rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'for' anno? idseq 'in' rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'

        caseatom
            : ID
            | 'this'
            | literal
            | '(' rawseq tuple? ')'
            | '[' ('as' type ':')? rawseq? ']'
            | 'object' anno? cap? ('is' type)? members 'end'
            | '{' anno? cap? ID? typeparams? '(' lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
            | '@{' anno? cap? ID? typeparams? '(' lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
            | '@' (ID | STRING) typeargs? '(' positional? named? ')' '?'?
            | '__loc'
            | 'while' anno? rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'for' anno? idseq 'in' rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'

        atom
            : ID
            | 'this'
            | literal
            | '(' rawseq tuple? ')'
            | '[' ('as' type ':')? rawseq? ']'
            | 'object' anno? cap? ('is' type)? members 'end'
            | '{' anno? cap? ID? typeparams? '(' lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
            | '@{' anno? cap? ID? typeparams? '(' lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
            | '@' (ID | STRING) typeargs? '(' positional? named? ')' '?'?
            | '__loc'
            | 'if' anno? rawseq 'then' rawseq (elseif | ('else' annotatedrawseq))? 'end'
            | 'while' anno? rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'
            | 'for' anno? idseq 'in' rawseq 'do' rawseq ('else' annotatedrawseq)? 'end'

        tuple:
            ',' rawseq (',' rawseq)*

        lambdacaptures:
            '(' (lambdacapture | 'this') (',' (lambdacapture | 'this'))* ')'

        lambdacapture:
            ID (':' type)? ('=' infix)?

        lambdaparams:
            lambdaparam (',' lambdaparam)*

        lambdaparam:
            ID (':' type)? ('=' infix)?

        positional:
            rawseq (',' rawseq)*

        named:
            'where' namedarg (',' namedarg)*

        namedarg:
            ID '=' rawseq

        type:
            atomtype ('->' type)?

        atomtype
            : 'this'
            | cap
            | '(' infixtype tupletype? ')'
            | nominal
            | lambdatype
            | barelambdatype

        barelambdatype:
            '@{' cap? ID? typeparams? '(' (type (',' type)*)? ')' (':' type)? '?'? '}' (cap | gencap)? ('^' | '!')?

        lambdatype:
            '{' cap? ID? typeparams? ('(' | LPAREN_NEW) (type (',' type)*)? ')' (':' type)? '?'? '}' (cap | gencap)? ('^' | '!')?

        tupletype:
            ',' infixtype (',' infixtype)*

        infixtype:
            type antlr_5*

        isecttype:
            '&' type

        uniontype:
            '|' type

        nominal:
            ID ('.' ID)? typeargs? (cap | gencap)? ('^' | '!')?

        gencap:
            '#read' | '#send' | '#share' | '#alias' | '#any'

        cap:
            'iso' | 'trn' | 'ref' | 'val' | 'box' | 'tag'

        typeargs:
            '[' typearg (',' typearg)* ']'

        typeparams:
            '[' typeparam (',' typeparam)* ']'

        params:
            (param | '...') (',' (param | '...'))*

        typeparam:
            ID (':' type)? ('=' typearg)?

        typearg
            : type
            | literal
            | '#' postfix

        literal
            : 'true'
            | 'false'
            | FLOAT
            | INT
            | STRING

        param:
            ID ':' type ('=' infix)?

        antlr_0
            : binop
            | isop
            | 'as' type

        antlr_5
            : uniontype
            | isecttype

        antlr_2
            : dot
            | tilde
            | chain
            | typeargs
            | call
    }

    terminals
    {
        EOF:
            _ !.

        _:  (whitespace | line-comment | nested-comment | new-line)*

        more:
            [0-9a-zA-Z_']

        keyword
            : 'compile_intrinsic'
            | 'use'
            | 'type'
            | 'interface'
            | 'trait'
            | 'primitive'
            | 'struct'
            | 'class'
            | 'actor'
            | 'object'
            | 'as'
            | 'is'
            | 'isnt'
            | 'var'
            | 'let'
            | 'embed'
            | 'new'
            | 'fun'
            | 'be'
            | 'iso'
            | 'trn'
            | 'ref'
            | 'val'
            | 'box'
            | 'tag'
            | 'this'
            | 'return'
            | 'break'
            | 'continue'
            | 'consume'
            | 'recover'
            | 'if'
            | 'ifdef'
            | 'iftype'
            | 'then'
            | 'else'
            | 'elseif'
            | 'end'
            | 'for'
            | 'in'
            | 'while'
            | 'do'
            | 'repeat'
            | 'until'
            | 'match'
            | 'where'
            | 'try'
            | 'with'
            | 'error'
            | 'compile_error'
            | 'not'
            | 'and'
            | 'or'
            | 'xor'
            | 'digestof'
            | 'addressof'
            | '__loc'
            | 'true'
            | 'false'

        // tokens

        ID: !keyword ident

        ident
            : _ LETTER (LETTER | DIGIT | [_] | ['])*
            | _ [_] (LETTER | DIGIT | [_] | ['])*

        INT
            : _ "0b" (BINARY | [_])+
            | _ "0x" (HEX | [_])+
            | _ DIGIT (DIGIT | [_])*
            | _ ['] CHAR_CHAR* [']

        FLOAT:
            _ DIGIT ![bx] (DIGIT | [_])* ([.] DIGIT (DIGIT | [_])*)? EXP?

        STRING
            : _ triple-x (!triple-x .)* triple-x ["]*
            | _ ["] STRING_CHAR* ["]

        triple-x:
            "\"\"\""

        LPAREN_NEW:
            new-line "("

        LSQUARE_NEW:
            new-line "["

        MINUS_NEW:
            new-line "-"

        MINUS_TILDE_NEW:
            new-line "-~"

        line-comment:
            "//" (!"\n" .)*

        nested-comment:
            [/][*] nested-comment-text [*][/]

        nested-comment-text:
            nested-comment-text-item*

        nested-comment-text-item
            : nested-comment
            / !( [/][*] / [*][/] ) .

        whitespace:
            (" " | "\t" | "\r")+

        new-line:
            line-break _

        // fragments

        line-break
	        = [\u000A]
	        / [\u000D][\u000A]
	        / [\u000D]

        line-break-character
	        = [\u000A]
	        / [\u000D]

        CHAR_CHAR
            : "\\\'" 
            | CHAR_ESC
            | !("\'" | "\\") .
  
        STRING_CHAR
            : "\\" "\""
            | ESC
            | !("\"" | "\\") .

        EXP:
            [eE][+-]? (DIGIT | '_')+

        LETTER:
            [a-zA-Z]

        DIGIT:
            [0-9]

        BINARY:
            [01]


        HEX:
            [0-9a-fA-F]

        ESC
            : CHAR_ESC
            | UNICODE_ESC
            | UNICODE2_ESC

        CHAR_ESC
            : "\\" ([abefnrtv0] | "\\")
            | HEX_ESC

        HEX_ESC:
            "\\x" HEX HEX

        UNICODE_ESC:
            "\\u" HEX HEX HEX HEX

        UNICODE2_ESC:
            "\\U" HEX HEX HEX HEX HEX HEX
    }
}